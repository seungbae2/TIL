# 코루틴 빌더

## launch

launch가 작동하는 방식은 thread 함수를 호출하여 새로운 스레드를 시작하는 것과 비슷하다. 코루틴을 시작하면 불꽃놀이를 할 때 불꽃이 하늘 위로 각자 퍼지는 것처럼 별개로 실행된다. 

launch 함수는 CoroutineScope 인터페이스의 확장 함수이다. CoroutineScope 인터페이스는 부모 코루틴과 자식 코루틴 사이의 관계를 정립하기 위한 목적으로 사용되는 구조화된 동시성(structued concurrency)의 핵심이다. 

launch가 작동하는 방식은 데몬 스레드와 어느 정도 비슷하지만 훨씬 가볍다. (launch와 데몬스레드를 비교하는 이유는 둘 다 프로그램이 끝나는 걸 막을 수 없기 때문) 이런 이런 비교 방식은 처음엔 유용할 수 있지만 나중엔 문제가 될 수 있다. 블로킹된 스레드를 유지하는 건 비용이 드는 일이지만 중단된 코루틴을 유지하는 건 공짜나 다름이 없다. 둘 다 별개의 작업을 시작하며 작업을 하는 동안 프로그램이 끝나는 걸 막는 무언가가 필요하다는 점에서는 비슷하다.  

## runBlocking

runBlocking은 아주 특이한 코루틴 빌더이다. 코루틴이 중단되었을 경우 runBlocking 빌더는 중단 메인 함수와 마찬가지로 시작한 스레드를 중단시킨다. 따라서 runBlocking 내부에서 delay(1000L)을 호출하면 Thread.sleep(1000L)과 비슷하게 작동한다.

runBlocking이 사용되는 특수한 경우는 실제로 두 가지가 있다. 첫 번째 경우는 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 메인 함수이다. 또 다른 경우는 같은 이유로 스레드를 블로킹할 필요가 있는 유닛테스트이다.

runBlocking은 코루틴 빌더로 중요하게 사용되었지만 현재는 거의 사용되지 않는다. 유닛 테스트에서는 코루틴을 가상 시간으로 실행시키는 runTest가 주로 사용되고 있다. 메인 함수는 runBlocking 대신에 suspend를 붙여 중단 함수로 만드는 방법을 주로 사용한다. 

## async

async 코루틴 빌더는 launch와 비슷하지만 값을 생성하도록 설계되어 있다. 이 값은 람다 표현식에 의해 반환되어야 한다. async 함수는 Deferred<T> 타입의 객체를 리턴하며, 여기서 T는 생성되는 값의 타입이다. Deferred에는 작업이 끝나면 값을 반환하는 중단 메서드인 await가 있다. 

launch 빌더와 비슷하게 async 빌더는 호출되자마자 코루틴을 즉시 시작한다. 따라서 몇 개의 작업을 한번에 시작하고 모든 결과를 한꺼번에 기다릴 때 사용한다. 반환된 Deferred는 값이 생성되면 해당 값을 내부에 저장하기 때문에 await에서 값이 반환되는 즉시 값을 사용할 수 있다. 하지만 값이 생성되기 전에 await를 호출하면 값이 나올 때까지 기다리게 된다.

async는 값 생성할 때 사용되며 값이 필요하지 않을 때는 launch를 써야 한다. 

async 빌더는 두 가지 다른 곳에서 데이터를 얻어와 합치는 경우처럼, 두 작업을 병렬로 실행할 때 주로 사용된다.